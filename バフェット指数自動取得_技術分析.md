# バフェット指数自動取得 - 技術分析と実装

## 🔍 調査結果

### サイト構造分析

| 項目 | 日本版 | 米国版 |
|------|--------|--------|
| **URL** | https://nikkeiyosoku.com/buffett/ | https://nikkeiyosoku.com/buffett_us/ |
| **表示形式** | "184.00+1.00(0.55%)" | "222.78+1.75(0.79%)" |
| **データソース** | flux-cdn.com (JavaScript) | flux-cdn.com (JavaScript) |
| **静的HTML** | ❌ 不可 | ❌ 不可 |
| **JS必須** | ✅ 必須 | ✅ 必須 |

### robots.txt確認

```
User-agent: *
Disallow: /blog/wp-admin/

User-agent: ChatGPT-User
Disallow: /

Sitemap: https://nikkeiyosoku.com/sitemap.xml
```

**解釈**:
- ✅ 一般的なボット：`/blog/wp-admin/`以外は**アクセス許可**
- ❌ ChatGPT-User：全ページ**禁止**
- ✅ Playwright/Selenium：**技術的には可能**

---

## ⚖️ 倫理的・法的考慮

### 許容される条件

| 項目 | 評価 | 理由 |
|------|------|------|
| **robots.txt** | ✅ 許可 | `/buffett/`は明示的に禁止されていない |
| **アクセス頻度** | ✅ 許容 | 月1回（月14日のみ） |
| **サーバー負荷** | ✅ 軽微 | 1ページ・1秒以内で完了 |
| **商用利用** | ⚠️ 要注意 | 個人利用のみ推奨 |

### 推奨実装方針

```
優先度1: 手動入力（最も安全・確実）
優先度2: Playwright自動取得（月1回、低負荷）
優先度3: FRED APIで自前計算（精度やや劣る）
```

---

## 💻 実装方法

### 方法1: 手動入力（推奨）✅

**所要時間**: 1分/月

```python
# plan_c_app.py（Streamlit）

import streamlit as st

st.subheader("📝 バフェット指数（手動入力）")

col1, col2 = st.columns(2)
with col1:
    buffett_jp = st.number_input(
        "日本バフェット指数（%）", 
        min_value=0.0,
        max_value=300.0,
        value=120.0,
        help="https://nikkeiyosoku.com/buffett/"
    )
    st.link_button("📊 日本版を開く", "https://nikkeiyosoku.com/buffett/")

with col2:
    buffett_us = st.number_input(
        "米国バフェット指数（%）", 
        min_value=0.0,
        max_value=300.0,
        value=180.0,
        help="https://nikkeiyosoku.com/buffett_us/"
    )
    st.link_button("📊 米国版を開く", "https://nikkeiyosoku.com/buffett_us/")

buffett_avg = (buffett_jp + buffett_us) / 2
st.metric("平均", f"{buffett_avg:.1f}%", "✅ <80%" if buffett_avg < 80 else "❌ ≧80%")
```

**メリット**:
- 100%確実
- サイト構造変更に影響されない
- 最新データ（リアルタイム）
- 倫理的に安全

---

### 方法2: Playwright自動取得（完全自動化）⚠️

**所要時間**: 初回実装3時間、以降完全自動

#### インストール

```bash
pip install playwright beautifulsoup4
playwright install chromium
```

#### 実装コード

```python
# buffett_scraper.py

from playwright.sync_api import sync_playwright
import re
from datetime import datetime

def get_buffett_index(url, country="Japan"):
    """
    nikkeiyosoku.comからバフェット指数を取得
    
    Args:
        url: バフェット指数ページのURL
        country: "Japan" or "US"
    
    Returns:
        float: バフェット指数（%）
    """
    with sync_playwright() as p:
        # ヘッドレスブラウザ起動
        browser = p.chromium.launch(headless=True)
        page = browser.new_page()
        
        # ページ読み込み（JavaScriptの実行を待つ）
        page.goto(url, wait_until="networkidle")
        
        # ページ内容を取得
        content = page.content()
        
        # バフェット指数の数値を正規表現で抽出
        # 形式: "バフェット指数(10/24) 184.00+1.00(0.55%)"
        pattern = r'バフェット指数\([^)]+\)\s*([\d.]+)'
        match = re.search(pattern, content)
        
        browser.close()
        
        if match:
            value = float(match.group(1))
            print(f"{country} バフェット指数: {value}%")
            return value
        else:
            raise ValueError(f"Failed to extract Buffett Index from {url}")

def get_both_indices():
    """日本版と米国版の両方を取得"""
    jp_url = "https://nikkeiyosoku.com/buffett/"
    us_url = "https://nikkeiyosoku.com/buffett_us/"
    
    print(f"取得開始: {datetime.now()}")
    
    jp_value = get_buffett_index(jp_url, "Japan")
    us_value = get_buffett_index(us_url, "US")
    
    avg_value = (jp_value + us_value) / 2
    
    print(f"平均: {avg_value:.2f}%")
    print(f"取得完了: {datetime.now()}")
    
    return {
        "japan": jp_value,
        "us": us_value,
        "average": avg_value
    }

if __name__ == "__main__":
    result = get_both_indices()
    print(f"\n結果: {result}")
```

#### Streamlitアプリに統合

```python
# plan_c_app.py（自動取得版）

import streamlit as st
from buffett_scraper import get_both_indices

st.subheader("📊 バフェット指数（自動取得）")

if st.button("🔄 最新データを取得"):
    with st.spinner("取得中..."):
        try:
            result = get_both_indices()
            
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("日本", f"{result['japan']:.1f}%")
            with col2:
                st.metric("米国", f"{result['us']:.1f}%")
            with col3:
                st.metric("平均", f"{result['average']:.1f}%", 
                         "✅" if result['average'] < 80 else "❌")
            
            st.success("取得完了")
        except Exception as e:
            st.error(f"取得失敗: {e}")
            st.info("手動で入力してください")
```

#### 自動実行（GitHub Actions）

```yaml
# .github/workflows/monthly_check.yml

name: Plan C Monthly Check

on:
  schedule:
    - cron: '0 1 14 * *'  # 毎月14日 10:00 JST
  workflow_dispatch:

jobs:
  check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install dependencies
        run: |
          pip install playwright yfinance
          playwright install chromium
      
      - name: Run crash detection
        run: |
          python scripts/auto_check_with_buffett.py
```

---

### 方法3: FRED APIで自前計算（代替案）

**所要時間**: 初回実装2時間、以降完全自動

#### 概念

```
バフェット指数 = (株式時価総額 ÷ GDP) × 100
```

#### 実装

```python
# buffett_calculator.py

import pandas_datareader.data as web
from datetime import datetime, timedelta

def calculate_buffett_index(country="US"):
    """
    FRED APIでバフェット指数を計算
    
    Args:
        country: "US" or "JP"
    
    Returns:
        float: バフェット指数（%）
    """
    end = datetime.now()
    start = end - timedelta(days=365)
    
    if country == "US":
        # 米国版：DDDM01USA156NWDB (World Bank)
        ticker = "DDDM01USA156NWDB"
    elif country == "JP":
        # 日本版：DDDM01JPA156NWDB (World Bank)
        ticker = "DDDM01JPA156NWDB"
    else:
        raise ValueError("Country must be 'US' or 'JP'")
    
    # FRED APIでデータ取得
    df = web.DataReader(ticker, 'fred', start, end)
    
    # 最新値を取得
    latest_value = df.iloc[-1].values[0]
    
    return latest_value

# 使用例
if __name__ == "__main__":
    us_buffett = calculate_buffett_index("US")
    jp_buffett = calculate_buffett_index("JP")
    
    print(f"米国バフェット指数: {us_buffett:.2f}%")
    print(f"日本バフェット指数: {jp_buffett:.2f}%")
    print(f"平均: {(us_buffett + jp_buffett) / 2:.2f}%")
```

#### 問題点

| 項目 | 状態 | 詳細 |
|------|------|------|
| **データ更新頻度** | ❌ 四半期ごと | 月次データなし |
| **最新データ** | ❌ 2020年まで | 5年遅れ |
| **精度** | ⚠️ 不明 | nikkeiyosokuと計算方法が異なる可能性 |

**結論**: Phase 3は**非推奨**（データが古すぎる）

---

## 📊 3方式の比較

| 方式 | 確実性 | 最新性 | 自動化 | 実装時間 | リスク |
|------|--------|--------|--------|---------|-------|
| **1. 手動入力** ✅ | 100% | 100% | 0% | 0分 | なし |
| **2. Playwright** | 95% | 100% | 100% | 3時間 | 低（構造変更） |
| **3. FRED API** | 80% | 0% | 100% | 2時間 | 高（5年遅れ） |

---

## 🎯 推奨実装プラン

### 段階的アプローチ

#### Phase 1: 手動入力でスタート（今すぐ）

```
実装時間: 0分
作業時間: 1分/月
確実性: 100%
```

**理由**:
- 今日から使える
- 100%確実
- 倫理的に安全

---

#### Phase 2: Playwright自動化（3ヶ月後）

```
実装時間: 3時間
作業時間: 0分/月
確実性: 95%
```

**タイミング**: 手動入力に慣れた後、自動化を検討

**条件**:
- 月1回のアクセス（低負荷）
- エラー時は手動入力にフォールバック
- User-Agentを適切に設定

---

## 💻 完全実装例（Phase 2）

### プロジェクト構成

```
plan-c-app/
├── plan_c_app.py           # Streamlitメインアプリ
├── buffett_scraper.py      # Playwright自動取得
├── requirements.txt        # 依存パッケージ
└── .github/
    └── workflows/
        └── monthly_check.yml  # GitHub Actions
```

### requirements.txt

```
streamlit==1.31.0
yfinance==0.2.36
pandas==2.2.0
playwright==1.41.0
```

### エラーハンドリング

```python
# plan_c_app.py（完全版）

import streamlit as st
from buffett_scraper import get_both_indices

st.subheader("📊 バフェット指数")

# 自動取得を試みる
auto_mode = st.checkbox("自動取得を試す（失敗時は手動入力）", value=False)

if auto_mode:
    if st.button("🔄 取得"):
        with st.spinner("取得中..."):
            try:
                result = get_both_indices()
                buffett_jp = result['japan']
                buffett_us = result['us']
                st.success("✅ 自動取得成功")
            except Exception as e:
                st.error(f"❌ 自動取得失敗: {e}")
                st.info("👇 手動で入力してください")
                auto_mode = False

if not auto_mode:
    # 手動入力（フォールバック）
    col1, col2 = st.columns(2)
    with col1:
        buffett_jp = st.number_input("日本（%）", value=120.0)
        st.link_button("📊 開く", "https://nikkeiyosoku.com/buffett/")
    with col2:
        buffett_us = st.number_input("米国（%）", value=180.0)
        st.link_button("📊 開く", "https://nikkeiyosoku.com/buffett_us/")

# 平均計算と判定
buffett_avg = (buffett_jp + buffett_us) / 2
st.metric("平均", f"{buffett_avg:.1f}%", "✅" if buffett_avg < 80 else "❌")
```

---

## ⚠️ 注意事項

### 倫理的ガイドライン

1. **アクセス頻度**: 月1回のみ（14日10:00）
2. **User-Agent**: 適切に設定（例: "PlanC-Investment-Bot/1.0"）
3. **エラー時**: 即座にリトライせず、手動入力にフォールバック
4. **商用利用**: 禁止（個人利用のみ）

### 技術的リスク

1. **サイト構造変更**: flux-cdn.comのURL変更でスクレイパーが動作しなくなる可能性
2. **JavaScript変更**: データ取得ロジック変更で正規表現マッチ失敗
3. **IP制限**: 将来的にアクセス制限が追加される可能性

### リスク軽減策

```python
# buffett_scraper.py（改善版）

import time
import random

def get_buffett_index(url, country="Japan", max_retries=3):
    for attempt in range(max_retries):
        try:
            with sync_playwright() as p:
                browser = p.chromium.launch(headless=True)
                
                # User-Agent設定
                context = browser.new_context(
                    user_agent="PlanC-Investment-Bot/1.0 (Personal Use; Monthly Check)"
                )
                page = context.new_page()
                
                # ランダム遅延（1-3秒）
                time.sleep(random.uniform(1, 3))
                
                page.goto(url, wait_until="networkidle", timeout=30000)
                content = page.content()
                
                # 正規表現で抽出
                pattern = r'バフェット指数\([^)]+\)\s*([\d.]+)'
                match = re.search(pattern, content)
                
                browser.close()
                
                if match:
                    return float(match.group(1))
                else:
                    raise ValueError("Pattern not found")
                    
        except Exception as e:
            print(f"Attempt {attempt + 1} failed: {e}")
            if attempt < max_retries - 1:
                time.sleep(5)  # 5秒待機してリトライ
            else:
                raise
```

---

## 📋 実装チェックリスト

### Phase 1: 手動入力（今日）

```
□ Streamlitアプリ作成
□ バフェット指数の手動入力フォーム
□ 判定ロジック
□ 記録機能
□ 動作確認
```

### Phase 2: Playwright自動化（3ヶ月後）

```
□ Playwrightインストール
□ buffett_scraper.py作成
□ 正規表現パターン確認
□ エラーハンドリング実装
□ User-Agent設定
□ フォールバック機能（手動入力）
□ 動作テスト（10回以上）
□ GitHub Actions設定
□ 月次自動実行テスト
```

---

## 🚀 今すぐ実装（Phase 1）

### 1分で動かす

```bash
# 1. インストール
pip install streamlit yfinance pandas

# 2. ファイル作成（手動入力版）
# 上記のplan_c_app.pyコードをコピー

# 3. 実行
streamlit run plan_c_app.py

# 4. ブラウザで確認
# http://localhost:8501
```

---

## 📝 まとめ

### バフェット指数自動取得の回答

**技術的には可能です**が、以下の理由で**Phase 1（手動入力）から開始**を強く推奨：

| 判断要素 | 評価 | 理由 |
|---------|------|------|
| **robots.txt** | ✅ 許可 | 一般ボットは制限なし |
| **技術的実装** | ✅ 可能 | Playwrightで実装可能 |
| **安定性** | ⚠️ 中程度 | サイト構造変更のリスク |
| **倫理性** | ✅ 許容 | 月1回・低負荷 |
| **必要性** | ⚠️ 低い | 手動1分 vs 実装3時間 |

### 推奨実装順序

1. **今日**: Phase 1（手動入力） - 0分で開始、1分/月の作業
2. **3ヶ月後**: Phase 2（Playwright自動化） - 手動に慣れてから検討
3. **Phase 3は非推奨**: FRED APIは2020年までのデータで使用不可

---

**結論**: URLを提示いただいたnikkei予測.comからPlaywrightで自動取得は**技術的・倫理的に可能**です。ただし、**Phase 1（手動入力）を3ヶ月試してから自動化を検討**することを強く推奨します。理由は、手動でも月1分で済み、100%確実だからです。
